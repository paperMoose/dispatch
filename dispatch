#!/usr/bin/env bash
set -euo pipefail

# dispatch — Orchestrate Claude Code agents in git worktrees
# https://github.com/paperMoose/dispatch

VERSION="0.2.0"
DISPATCH_SESSION="dispatch"
WORKTREE_DIR=".worktrees"

# ---------------------------------------------------------------------------
# Colors and formatting
# ---------------------------------------------------------------------------
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# Tab colors for iTerm2 (cycle through these)
TAB_COLORS=("2E86AB" "A23B72" "F18F01" "C73E1D" "3B1F2B" "44BBA4" "E94F37" "393E41")

log_info()  { echo -e "${BLUE}▸${NC} $*"; }
log_ok()    { echo -e "${GREEN}✓${NC} $*"; }
log_warn()  { echo -e "${YELLOW}⚠${NC} $*"; }
log_error() { echo -e "${RED}✗${NC} $*" >&2; }
log_dim()   { echo -e "${DIM}$*${NC}"; }

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------
DISPATCH_CONFIG="${DISPATCH_CONFIG:-$HOME/.dispatch.yml}"

# Capture env vars set by user (before defaults)
_ENV_BASE_BRANCH="${DISPATCH_BASE_BRANCH:-}"
_ENV_MODEL="${DISPATCH_MODEL:-}"
_ENV_MAX_TURNS="${DISPATCH_MAX_TURNS:-}"
_ENV_MAX_BUDGET="${DISPATCH_MAX_BUDGET:-}"
_ENV_ALLOWED_TOOLS="${DISPATCH_ALLOWED_TOOLS:-}"
_ENV_CLAUDE_TIMEOUT="${DISPATCH_CLAUDE_TIMEOUT:-}"

# Initialize with empty — config file and then defaults fill these in
DISPATCH_BASE_BRANCH=""
DISPATCH_MODEL=""
DISPATCH_MAX_TURNS=""
DISPATCH_MAX_BUDGET=""
DISPATCH_ALLOWED_TOOLS=""
DISPATCH_CLAUDE_TIMEOUT=""

load_config() {
    # 1. Load config file values
    if [[ -f "$DISPATCH_CONFIG" ]]; then
        while IFS= read -r line; do
            [[ "$line" =~ ^#.*$ || -z "$line" ]] && continue
            local key="${line%%:*}"
            local value="${line#*: }"
            key=$(echo "$key" | xargs)  # trim whitespace
            value="${value%\"}"
            value="${value#\"}"
            case "$key" in
                base_branch)     DISPATCH_BASE_BRANCH="$value" ;;
                model)           DISPATCH_MODEL="$value" ;;
                max_turns)       DISPATCH_MAX_TURNS="$value" ;;
                max_budget)      DISPATCH_MAX_BUDGET="$value" ;;
                allowed_tools)   DISPATCH_ALLOWED_TOOLS="$value" ;;
                worktree_dir)    WORKTREE_DIR="$value" ;;
                claude_timeout)  DISPATCH_CLAUDE_TIMEOUT="$value" ;;
            esac
        done < "$DISPATCH_CONFIG"
    fi

    # 2. Env vars override config file (user's explicit env takes precedence)
    [[ -n "$_ENV_BASE_BRANCH" ]] && DISPATCH_BASE_BRANCH="$_ENV_BASE_BRANCH"
    [[ -n "$_ENV_MODEL" ]] && DISPATCH_MODEL="$_ENV_MODEL"
    [[ -n "$_ENV_MAX_TURNS" ]] && DISPATCH_MAX_TURNS="$_ENV_MAX_TURNS"
    [[ -n "$_ENV_MAX_BUDGET" ]] && DISPATCH_MAX_BUDGET="$_ENV_MAX_BUDGET"
    [[ -n "$_ENV_ALLOWED_TOOLS" ]] && DISPATCH_ALLOWED_TOOLS="$_ENV_ALLOWED_TOOLS"
    [[ -n "$_ENV_CLAUDE_TIMEOUT" ]] && DISPATCH_CLAUDE_TIMEOUT="$_ENV_CLAUDE_TIMEOUT"

    # 3. Apply defaults for anything still unset
    DISPATCH_BASE_BRANCH="${DISPATCH_BASE_BRANCH:-dev}"
    DISPATCH_ALLOWED_TOOLS="${DISPATCH_ALLOWED_TOOLS:-Bash,Read,Write,Edit,Glob,Grep,Task,WebSearch,WebFetch}"
    DISPATCH_CLAUDE_TIMEOUT="${DISPATCH_CLAUDE_TIMEOUT:-30}"
}

# ---------------------------------------------------------------------------
# Git helpers
# ---------------------------------------------------------------------------
git_root() {
    git rev-parse --show-toplevel 2>/dev/null || {
        log_error "Not inside a git repository"
        exit 1
    }
}

ensure_worktree_dir() {
    local root
    root="$(git_root)"
    local dir="$root/$WORKTREE_DIR"
    mkdir -p "$dir"

    # Add to .gitignore if not already there
    local gitignore="$root/.gitignore"
    if [[ ! -f "$gitignore" ]]; then
        touch "$gitignore"
    fi
    grep -qxF "$WORKTREE_DIR/" "$gitignore" 2>/dev/null || echo "$WORKTREE_DIR/" >> "$gitignore"

    echo "$dir"
}

worktree_path() {
    local id="$1"
    local root
    root="$(git_root)"
    echo "$root/$WORKTREE_DIR/$id"
}

create_worktree() {
    local id="$1"
    local branch="$2"
    local base="${3:-$DISPATCH_BASE_BRANCH}"
    local wt_path
    wt_path="$(worktree_path "$id")"

    if [[ -d "$wt_path" ]]; then
        log_warn "Worktree already exists: $wt_path"
        return 0
    fi

    ensure_worktree_dir > /dev/null

    log_info "Creating worktree: ${BOLD}$id${NC} (branch: $branch off $base)"
    git fetch origin "$base" 2>/dev/null || true
    git worktree add -b "$branch" "$wt_path" "origin/$base" 2>/dev/null || {
        # Branch might already exist
        git worktree add "$wt_path" "$branch" 2>/dev/null || {
            log_error "Failed to create worktree"
            exit 1
        }
    }
    log_ok "Worktree created at $wt_path"
}

remove_worktree() {
    local id="$1"
    local wt_path
    wt_path="$(worktree_path "$id")"

    if [[ ! -d "$wt_path" ]]; then
        log_warn "Worktree not found: $id"
        return 0
    fi

    log_info "Removing worktree: $id"
    git worktree remove --force "$wt_path" 2>/dev/null || {
        log_error "Failed to remove worktree. Try: git worktree remove --force $wt_path"
        return 1
    }
    git worktree prune 2>/dev/null
    log_ok "Worktree removed: $id"
}

# ---------------------------------------------------------------------------
# tmux helpers
# ---------------------------------------------------------------------------
ensure_tmux() {
    if ! command -v tmux &>/dev/null; then
        log_error "tmux is required. Install with: brew install tmux"
        exit 1
    fi
}

ensure_session() {
    if ! tmux has-session -t "$DISPATCH_SESSION" 2>/dev/null; then
        tmux new-session -d -s "$DISPATCH_SESSION" -n "dispatch"
        # Mark the initial window so we can identify it
        tmux send-keys -t "$DISPATCH_SESSION:dispatch" "# Dispatch control window" Enter
    fi
}

window_exists() {
    local id="$1"
    tmux list-windows -t "$DISPATCH_SESSION" -F "#{window_name}" 2>/dev/null | grep -qxF "$id"
}

create_window() {
    local id="$1"
    local cwd="$2"

    if window_exists "$id"; then
        log_warn "Window '$id' already exists in tmux session"
        return 1
    fi

    ensure_session
    tmux new-window -t "$DISPATCH_SESSION" -n "$id" -c "$cwd"

    # Set tab color (cycle through palette)
    local window_count
    window_count=$(tmux list-windows -t "$DISPATCH_SESSION" 2>/dev/null | wc -l | tr -d ' ')
    local color_idx=$(( (window_count - 1) % ${#TAB_COLORS[@]} ))
    local hex="${TAB_COLORS[$color_idx]}"
    local r=$((16#${hex:0:2}))
    local g=$((16#${hex:2:2}))
    local b=$((16#${hex:4:2}))

    # iTerm2 tab color escape sequences
    tmux send-keys -t "$DISPATCH_SESSION:$id" "printf '\\033]6;1;bg;red;brightness;${r}\\007'" Enter
    tmux send-keys -t "$DISPATCH_SESSION:$id" "printf '\\033]6;1;bg;green;brightness;${g}\\007'" Enter
    tmux send-keys -t "$DISPATCH_SESSION:$id" "printf '\\033]6;1;bg;blue;brightness;${b}\\007'" Enter

    # Set iTerm2 badge
    local badge
    badge=$(echo -n "$id" | base64)
    tmux send-keys -t "$DISPATCH_SESSION:$id" "printf '\\033]1337;SetBadgeFormat=${badge}\\007'" Enter
}

# ---------------------------------------------------------------------------
# Notifications
# ---------------------------------------------------------------------------
notify() {
    local title="$1"
    local message="$2"

    # macOS native notification (no dependencies)
    if command -v osascript &>/dev/null; then
        osascript -e "display notification \"$message\" with title \"$title\" sound name \"Glass\"" 2>/dev/null || true
    fi
}

# ---------------------------------------------------------------------------
# Claude Code readiness
# ---------------------------------------------------------------------------
wait_for_claude() {
    local target="$1"
    local max_wait="${DISPATCH_CLAUDE_TIMEOUT:-30}"
    local waited=0

    while (( waited < max_wait )); do
        # Capture the last few lines of the pane
        local pane_content
        pane_content=$(tmux capture-pane -t "$target" -p -S -5 2>/dev/null || true)

        # Claude Code shows ">" prompt or "?" prompt when ready
        # Also check for common ready indicators
        if echo "$pane_content" | grep -qE '^\s*[>?]\s*$|╭|Welcome|claude'; then
            return 0
        fi

        sleep 1
        (( waited++ ))
    done

    # Timed out — proceed anyway (best effort)
    log_warn "Claude Code may not be fully initialized (waited ${max_wait}s)"
    return 0
}

# ---------------------------------------------------------------------------
# Linear integration
# ---------------------------------------------------------------------------
fetch_linear_ticket() {
    local ticket_id="$1"

    # Try using Linear MCP if available, fall back to gh/API
    # For now, use a simple approach with the linear CLI or API
    local title=""
    local description=""

    # Check if it looks like a Linear ticket ID (e.g., HEY-837)
    if [[ "$ticket_id" =~ ^[A-Z]+-[0-9]+$ ]]; then
        log_info "Fetching Linear ticket: $ticket_id"

        # Try Linear API (requires LINEAR_API_KEY)
        if [[ -n "${LINEAR_API_KEY:-}" ]]; then
            local team_key="${ticket_id%%-*}"
            local issue_num="${ticket_id##*-}"
            local response
            response=$(curl -s -X POST https://api.linear.app/graphql \
                -H "Content-Type: application/json" \
                -H "Authorization: $LINEAR_API_KEY" \
                -d "{\"query\": \"{ issueSearch(filter: { number: { eq: $issue_num }, team: { key: { eq: \\\"$team_key\\\" } } }) { nodes { title description identifier url branchName } } }\"}" 2>/dev/null) || true

            if [[ -n "$response" ]]; then
                title=$(echo "$response" | python3 -c "import sys,json; nodes=json.load(sys.stdin).get('data',{}).get('issueSearch',{}).get('nodes',[]); print(nodes[0]['title'] if nodes else '')" 2>/dev/null) || true
                description=$(echo "$response" | python3 -c "import sys,json; nodes=json.load(sys.stdin).get('data',{}).get('issueSearch',{}).get('nodes',[]); print(nodes[0].get('description','') if nodes else '')" 2>/dev/null) || true
            fi
        fi

        if [[ -z "$title" ]]; then
            log_warn "Could not fetch ticket details (set LINEAR_API_KEY for auto-fetch)"
            title="$ticket_id"
        else
            log_ok "Ticket: $title"
        fi
    fi

    echo "$title"
    echo "---"
    echo "$description"
}

# ---------------------------------------------------------------------------
# Build Claude Code command
# ---------------------------------------------------------------------------
build_claude_cmd() {
    local prompt="$1"
    local mode="$2"  # interactive or headless
    local wt_path="$3"
    local extra_args="${4:-}"

    local cmd="claude"

    if [[ "$mode" == "headless" ]]; then
        cmd="$cmd -p"
    fi

    if [[ -n "$DISPATCH_MODEL" ]]; then
        cmd="$cmd --model $DISPATCH_MODEL"
    fi

    if [[ "$mode" == "headless" ]]; then
        cmd="$cmd --allowedTools \"$DISPATCH_ALLOWED_TOOLS\""

        if [[ -n "$DISPATCH_MAX_TURNS" ]]; then
            cmd="$cmd --max-turns $DISPATCH_MAX_TURNS"
        fi

        if [[ -n "$DISPATCH_MAX_BUDGET" ]]; then
            cmd="$cmd --max-budget-usd $DISPATCH_MAX_BUDGET"
        fi

        cmd="$cmd --output-format json"
    fi

    if [[ -n "$extra_args" ]]; then
        cmd="$cmd $extra_args"
    fi

    # For headless, write prompt to a file to avoid shell quoting issues
    if [[ "$mode" == "headless" ]]; then
        local prompt_file="$wt_path/.dispatch-prompt.txt"
        printf '%s' "$prompt" > "$prompt_file"
        cmd="$cmd \"\$(cat '$prompt_file')\""
    fi

    echo "$cmd"
}

# ---------------------------------------------------------------------------
# Commands
# ---------------------------------------------------------------------------
_launch_agent() {
    local input="$1"
    local headless="$2"
    local extra_args="$3"
    local skip_worktree="$4"
    local prompt_file_arg="$5"

    # Determine if input is a ticket ID or free text
    local id=""
    local prompt=""
    local branch=""

    if [[ "$input" =~ ^[A-Z]+-[0-9]+$ ]]; then
        id=$(echo "$input" | tr '[:upper:]' '[:lower:]')
        branch="${id}"

        # Fetch ticket details for the prompt
        local ticket_info
        ticket_info=$(fetch_linear_ticket "$input")
        local title
        title=$(echo "$ticket_info" | head -1)
        local description
        description=$(echo "$ticket_info" | tail -n +3)

        if [[ -n "$description" && "$description" != "" ]]; then
            prompt="Linear ticket $input: $title

$description

Work on this ticket. Create commits as you go. When done, push the branch."
        else
            prompt="Work on ticket $input: $title. Create commits as you go. When done, push the branch."
        fi

        # Use ticket ID for window name
        id="$input"
    else
        # Free text — generate an ID from the prompt
        id="task-$(date +%s | tail -c 6)"
        branch="$id"
        prompt="$input"
    fi

    # Load prompt from file if specified
    if [[ -n "$prompt_file_arg" ]]; then
        if [[ ! -f "$prompt_file_arg" ]]; then
            log_error "Prompt file not found: $prompt_file_arg"
            return 1
        fi
        if [[ "$input" =~ ^[A-Z]+-[0-9]+$ ]]; then
            log_warn "Ticket prompt for $input overridden by --prompt-file"
        fi
        prompt=$(cat "$prompt_file_arg")
    fi

    # Check if already running
    if window_exists "$id"; then
        log_error "Agent '$id' is already running. Use 'dispatch stop $id' first."
        return 1
    fi

    # Create worktree
    local wt_path
    if [[ "$skip_worktree" == true ]]; then
        wt_path="$(git_root)"
    else
        create_worktree "$id" "$branch" "$DISPATCH_BASE_BRANCH"
        wt_path="$(worktree_path "$id")"
    fi

    # Create tmux window
    create_window "$id" "$wt_path"

    # Build and send the Claude command
    local mode="interactive"
    [[ "$headless" == true ]] && mode="headless"

    local claude_cmd
    claude_cmd=$(build_claude_cmd "$prompt" "$mode" "$wt_path" "$extra_args")

    if [[ "$mode" == "interactive" ]]; then
        # Interactive: launch claude, wait for it to be ready, then send prompt
        local model_flag=""
        [[ -n "$DISPATCH_MODEL" ]] && model_flag="--model $DISPATCH_MODEL"
        tmux send-keys -t "$DISPATCH_SESSION:$id" "claude $model_flag" Enter
        wait_for_claude "$DISPATCH_SESSION:$id"
        # Write prompt to file and paste via named tmux buffer to handle special chars
        local pf="$wt_path/.dispatch-prompt.txt"
        printf '%s' "$prompt" > "$pf"
        local buf_name="dispatch-${id//[^a-zA-Z0-9]/-}"
        tmux load-buffer -b "$buf_name" "$pf"
        tmux paste-buffer -b "$buf_name" -t "$DISPATCH_SESSION:$id"
        tmux delete-buffer -b "$buf_name" 2>/dev/null || true
        tmux send-keys -t "$DISPATCH_SESSION:$id" Enter
    else
        # Headless: run with -p flag, tee to log, notify on completion
        local log_file="$wt_path/.dispatch.log"
        tmux send-keys -t "$DISPATCH_SESSION:$id" "$claude_cmd 2>&1 | tee -a $log_file; dispatch _notify-done $id" Enter
    fi

    echo ""
    log_ok "Agent ${BOLD}$id${NC} launched (${mode})"
    log_dim "  Worktree: $wt_path"
    log_dim "  Branch:   $branch"
    if [[ "$headless" == true ]]; then
        log_dim "  Logs:     dispatch logs $id"
        log_dim "  Stop:     dispatch stop $id"
    fi
}

cmd_run() {
    local inputs=()
    local headless=false
    local prompt_file=""
    local extra_args=""
    local skip_worktree=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --headless|-H)      headless=true; shift ;;
            --model|-m)         DISPATCH_MODEL="$2"; shift 2 ;;
            --max-turns)        DISPATCH_MAX_TURNS="$2"; shift 2 ;;
            --max-budget)       DISPATCH_MAX_BUDGET="$2"; shift 2 ;;
            --base|-b)          DISPATCH_BASE_BRANCH="$2"; shift 2 ;;
            --prompt-file|-f)   prompt_file="$2"; shift 2 ;;
            --no-worktree)      skip_worktree=true; shift ;;
            --*)                extra_args="$extra_args $1"; shift ;;
            *)                  inputs+=("$1"); shift ;;
        esac
    done

    if [[ ${#inputs[@]} -eq 0 && -z "$prompt_file" ]]; then
        log_error "Usage: dispatch run <ticket|prompt> [ticket2 ...] [options]"
        echo ""
        echo "  dispatch run HEY-837                         # from Linear ticket"
        echo "  dispatch run HEY-837 HEY-838 HEY-839        # batch launch"
        echo "  dispatch run HEY-837 --headless              # run in background"
        echo "  dispatch run \"Fix the auth bug\"               # free text prompt"
        echo "  dispatch run HEY-837 --model sonnet          # specific model"
        echo "  dispatch run HEY-837 --max-turns 10          # limit turns"
        echo "  dispatch run HEY-837 --base main             # branch off main"
        exit 1
    fi

    ensure_tmux

    local batch=$(( ${#inputs[@]} > 1 ? 1 : 0 ))

    if (( batch )); then
        log_info "Batch launching ${#inputs[@]} agents..."
        echo ""
    fi

    for input in "${inputs[@]}"; do
        _launch_agent "$input" "$headless" "$extra_args" "$skip_worktree" "$prompt_file"
    done

    echo ""

    # For single interactive agent, attach to session
    if [[ "$headless" == false && ${#inputs[@]} -eq 1 ]]; then
        log_info "Attaching to tmux session..."
        log_dim "  Detach with: Ctrl-B then D"
        echo ""
        if [[ "${TERM_PROGRAM:-}" == "iTerm.app" ]]; then
            tmux -CC attach -t "$DISPATCH_SESSION"
        else
            tmux attach -t "$DISPATCH_SESSION"
        fi
    elif (( batch )); then
        log_ok "All agents launched. Use ${BOLD}dispatch attach${NC} to view tabs."
    fi
}

cmd_list() {
    ensure_tmux

    if ! tmux has-session -t "$DISPATCH_SESSION" 2>/dev/null; then
        log_info "No dispatch session running"
        return
    fi

    echo ""
    echo -e "${BOLD}Running Agents${NC}"
    echo -e "${DIM}──────────────────────────────────────────────${NC}"

    local root
    root="$(git_root 2>/dev/null || echo "")"

    local format="#{window_name}|#{pane_current_command}|#{pane_current_path}|#{pane_dead}"
    while IFS='|' read -r name cmd path dead; do
        [[ "$name" == "dispatch" ]] && continue  # Skip control window

        local status_icon status_text
        if [[ "$dead" == "1" ]]; then
            status_icon="${RED}●${NC}"
            status_text="exited"
        elif [[ "$cmd" == "claude" || "$cmd" == "node" ]]; then
            status_icon="${GREEN}●${NC}"
            status_text="running"
        else
            status_icon="${YELLOW}●${NC}"
            status_text="idle"
        fi

        local short_path="$path"
        [[ -n "$root" ]] && short_path="${path#"$root/"}"

        echo -e "  $status_icon ${BOLD}$name${NC}  ${DIM}($status_text)${NC}"
        echo -e "    ${DIM}path: $short_path${NC}"
    done < <(tmux list-windows -t "$DISPATCH_SESSION" -F "$format" 2>/dev/null)

    echo ""
}

cmd_logs() {
    local id="${1:-}"

    if [[ -z "$id" ]]; then
        log_error "Usage: dispatch logs <agent-id>"
        exit 1
    fi

    # Check for log file first (headless mode)
    local wt_path
    wt_path="$(worktree_path "$id")"
    local log_file="$wt_path/.dispatch.log"

    if [[ -f "$log_file" ]]; then
        log_info "Tailing log: $log_file"
        tail -f "$log_file"
    elif window_exists "$id"; then
        # Fall back to tmux capture
        log_info "Capturing output from tmux pane..."
        tmux capture-pane -t "$DISPATCH_SESSION:$id" -p -S -100
    else
        log_error "Agent '$id' not found"
        exit 1
    fi
}

cmd_stop() {
    local id="${1:-}"

    if [[ -z "$id" ]]; then
        log_error "Usage: dispatch stop <agent-id>"
        exit 1
    fi

    if ! window_exists "$id"; then
        log_warn "Agent '$id' is not running"
        return
    fi

    log_info "Stopping agent: $id"
    # Send Ctrl-C to gracefully stop Claude Code
    tmux send-keys -t "$DISPATCH_SESSION:$id" C-c
    sleep 1
    # Kill the window
    tmux kill-window -t "$DISPATCH_SESSION:$id" 2>/dev/null || true
    log_ok "Agent stopped: $id"
}

cmd_resume() {
    local id="${1:-}"
    local headless=false

    if [[ -z "$id" ]]; then
        log_error "Usage: dispatch resume <agent-id> [--headless]"
        exit 1
    fi

    shift || true
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --headless|-H) headless=true; shift ;;
            *) shift ;;
        esac
    done

    ensure_tmux

    local wt_path
    wt_path="$(worktree_path "$id")"

    if [[ ! -d "$wt_path" ]]; then
        log_error "Worktree not found for '$id'. Nothing to resume."
        exit 1
    fi

    # Check if already running
    if window_exists "$id"; then
        log_warn "Agent '$id' is already running. Attaching..."
        if [[ "${TERM_PROGRAM:-}" == "iTerm.app" ]]; then
            tmux -CC attach -t "$DISPATCH_SESSION"
        else
            tmux attach -t "$DISPATCH_SESSION"
        fi
        return
    fi

    # Create new window and resume claude with --continue
    create_window "$id" "$wt_path"

    if [[ "$headless" == false ]]; then
        local model_flag=""
        [[ -n "$DISPATCH_MODEL" ]] && model_flag="--model $DISPATCH_MODEL"
        tmux send-keys -t "$DISPATCH_SESSION:$id" "claude --continue $model_flag" Enter
        log_ok "Resumed agent: $id (interactive)"
        if [[ "${TERM_PROGRAM:-}" == "iTerm.app" ]]; then
            tmux -CC attach -t "$DISPATCH_SESSION"
        else
            tmux attach -t "$DISPATCH_SESSION"
        fi
    else
        local resume_prompt="Continue working on the task."
        local claude_cmd
        claude_cmd=$(build_claude_cmd "$resume_prompt" "headless" "$wt_path" "--continue")
        local log_file="$wt_path/.dispatch.log"
        tmux send-keys -t "$DISPATCH_SESSION:$id" "$claude_cmd 2>&1 | tee -a $log_file; dispatch _notify-done $id" Enter
        log_ok "Resumed agent: $id (headless)"
    fi
}

cmd_cleanup() {
    local id=""
    local all=false
    local delete_branch=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --all)            all=true; shift ;;
            --delete-branch)  delete_branch=true; shift ;;
            *)                id="$1"; shift ;;
        esac
    done

    if [[ "$all" == true ]]; then
        log_info "Cleaning up all worktrees..."
        local root
        root="$(git_root)"
        local wt_dir="$root/$WORKTREE_DIR"

        if [[ ! -d "$wt_dir" ]]; then
            log_info "No worktrees to clean up"
            return
        fi

        for dir in "$wt_dir"/*/; do
            [[ ! -d "$dir" ]] && continue
            local name
            name=$(basename "$dir")

            # Stop if running
            if window_exists "$name"; then
                cmd_stop "$name"
            fi

            remove_worktree "$name"

            if [[ "$delete_branch" == true ]]; then
                git branch -D "$name" 2>/dev/null && log_ok "Deleted branch: $name" || log_warn "Branch not found: $name"
            fi
        done
    elif [[ -n "$id" ]]; then
        # Stop if running
        if window_exists "$id"; then
            cmd_stop "$id"
        fi

        remove_worktree "$id"

        if [[ "$delete_branch" == true ]]; then
            git branch -D "$id" 2>/dev/null && log_ok "Deleted branch: $id" || log_warn "Branch not found: $id"
        fi
    else
        log_error "Usage: dispatch cleanup <agent-id> | --all [--delete-branch]"
        exit 1
    fi
}

cmd_attach() {
    ensure_tmux

    if ! tmux has-session -t "$DISPATCH_SESSION" 2>/dev/null; then
        log_error "No dispatch session running"
        exit 1
    fi

    if [[ "${TERM_PROGRAM:-}" == "iTerm.app" ]]; then
        tmux -CC attach -t "$DISPATCH_SESSION"
    else
        tmux attach -t "$DISPATCH_SESSION"
    fi
}

cmd_version() {
    echo "dispatch v$VERSION"
}

cmd_help() {
    cat <<'HELP'
dispatch — Orchestrate Claude Code agents in git worktrees

Usage:
  dispatch run <ticket|prompt> [more...] [options]  Launch agent(s)
  dispatch list                                     Show running agents
  dispatch logs <id>                                Tail agent output
  dispatch stop <id>                                Stop an agent
  dispatch resume <id> [--headless]                 Resume a stopped agent
  dispatch cleanup <id> | --all [--delete-branch]    Remove worktree(s)
  dispatch attach                                   Attach to tmux session

Run Options:
  --headless, -H          Run in background (no interactive tab)
  --model, -m <model>     Claude model (sonnet, opus, etc.)
  --max-turns <n>         Limit agent turns (headless only)
  --max-budget <usd>      Cap spending (headless only)
  --base, -b <branch>     Base branch for worktree (default: dev)
  --prompt-file, -f <file> Load prompt from file
  --no-worktree           Run in current directory (no worktree)

Examples:
  dispatch run HEY-837                      Interactive, from Linear ticket
  dispatch run HEY-837 --headless           Background mode
  dispatch run HEY-837 HEY-838 HEY-839     Batch launch (multiple agents)
  dispatch run "Fix the auth bug"           Free text prompt
  dispatch run HEY-837 -m sonnet            Use Sonnet model
  dispatch run HEY-837 --max-turns 10       Limit to 10 turns

Environment:
  LINEAR_API_KEY          Linear API key for ticket fetching
  DISPATCH_BASE_BRANCH   Default base branch (default: dev)
  DISPATCH_MODEL         Default model
  DISPATCH_CONFIG        Config file path (default: ~/.dispatch.yml)

Config (~/.dispatch.yml):
  base_branch: dev
  model: opus
  max_turns: 20
  claude_timeout: 30
  worktree_dir: .worktrees

HELP
}

# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------
main() {
    load_config

    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        run)        cmd_run "$@" ;;
        list|ls)    cmd_list ;;
        logs)       cmd_logs "$@" ;;
        stop)       cmd_stop "$@" ;;
        resume)     cmd_resume "$@" ;;
        cleanup)    cmd_cleanup "$@" ;;
        attach)     cmd_attach ;;
        _notify-done)
            # Internal: called by headless agents when they complete
            local agent_id="${1:-unknown}"
            notify "Dispatch" "Agent $agent_id finished"
            log_ok "Agent $agent_id completed"
            ;;
        version|-v|--version) cmd_version ;;
        help|-h|--help)       cmd_help ;;
        *)
            log_error "Unknown command: $cmd"
            echo ""
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
